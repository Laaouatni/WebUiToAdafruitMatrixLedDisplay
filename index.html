<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>
</head>

<body class="p-4 grid gap-4">
  <main class="relative flex w-full aspect-[32/8] justify-between transition-all">
    <img src="./img/ipiaCesarePesenti.jpg">
    <div class="bg-red-500 h-full w-20"></div>
    <div class="bg-green-500 h-full w-20"></div>
    <div class="bg-blue-500 h-full w-20"></div>
    <div class="bg-yellow-500 h-full w-20"></div>
    <div class="bg-slate-500 h-full w-20"></div>
  </main>
</body>

<script>
  convertUItoMatrixArrayOfColorsWithResolution(
    document.querySelector("main") || document.body,
    32,
    8,
  );

  function convertUItoMatrixArrayOfColorsWithResolution(
    paramHtmlElement,
    paramWidth,
    paramHeight,
  ) {
    return new Promise((res, rej) => {
      const clonedHtmlElement = paramHtmlElement.cloneNode(true);
      clonedHtmlElement.style.height = `${paramHeight}px`;
      clonedHtmlElement.style.width = `${paramWidth}px`;
      document.body.appendChild(clonedHtmlElement);
      html2canvas(clonedHtmlElement).then((thisHtmlCanvas) => {
        const thisHtmlCtx = thisHtmlCanvas.getContext("2d");
        const thisUint8ClampedArray = thisHtmlCtx.getImageData(0, 0, thisHtmlCanvas.width, thisHtmlCanvas.height).data;
        let result = [];
        let arrayPixelColors = [];
        for(let forPixelIndex = 0; forPixelIndex < (paramWidth*paramHeight); forPixelIndex++) {
          const redIndex = forPixelIndex * 4;
          const pixelColorObject = {
            R: thisUint8ClampedArray[redIndex],
            G: thisUint8ClampedArray[redIndex + 1],
            B: thisUint8ClampedArray[redIndex + 2],
            A: thisUint8ClampedArray[redIndex + 3],
          }
          const y = forPixelIndex/paramWidth;
          console.log(forPixelIndex, y);
          // arrayPixelColors[forPixelIndex] = pixelColorObject;
        }
        // console.log(arrayPixelColors);
      });
    });
  }
  // const ipEsp32 = '127.0.0.1:5500/index.html';
  // const ws = new WebSocket(`ws://${ipEsp32}/ws`);

  // ws.addEventListener("close", () => {
  //   window.location.reload();
  // });

  // ws.addEventListener("open", () => {
  //   setTimeout(() => {
  //     convertUItoMatrixArrayOfColorsWithResolution(
  //       document.querySelector("main") || document.body,
  //       32,
  //       8,
  //     );
  //   })

  //   // setInterval(() => {
  //   //   // const mainElement = document.querySelector("main");
  //   //   // mainElement.style.backgroundImage = `linear-gradient(90deg, hsl(${Math.random() * 360}, 100%, 50%), hsl(${Math.random() * 360}, 100%, 50%))`;

  //   //   convertUItoMatrixArrayOfColorsWithResolution(
  //   //     document.querySelector("main") || document.body,
  //   //     32,
  //   //     8,
  //   //   );
  //   // }, (200 * 8));
  // });


  // function sendBtnClick() {
  //   convertUItoMatrixArrayOfColorsWithResolution(
  //     document.querySelector("main") || document.body,
  //     32,
  //     8,
  //   );
  // };

  // const imgAverageColorPicker = new ColorThief();

  // function convertUItoMatrixArrayOfColorsWithResolution(
  //   htmlElement,
  //   x,
  //   y,
  // ) {
  //   return new Promise((resolve, reject) => {
  //     const clonedElement = htmlElement.cloneNode(true);
  //     clonedElement.style.zoom = "100% !important";

  //     // html2canvas(clonedElement).then((thisHtmlCanvas) => {
  //     html2canvas(htmlElement).then((thisHtmlCanvas) => {
  //       const thisHtmlCtx = thisHtmlCanvas.getContext("2d", { willReadFrequently: true });

  //       const canvasTotalWidth = thisHtmlCanvas.width;
  //       const canvasTotalHeight = thisHtmlCanvas.height;

  //       const canvasPartWidth = canvasTotalWidth / x;
  //       const canvasPartHeight = canvasTotalHeight / y;

  //       const result = [];

  //       for (let forY = 0; forY < y; forY++) {
  //         result[forY] = [];
  //         for (let forX = 0; forX < x; forX++) {
  //           const x0 = forX * canvasPartWidth;
  //           const y0 = forY * canvasPartHeight;

  //           const thisPartCanvas = document.createElement("canvas");
  //           thisPartCanvas.width = canvasPartWidth;
  //           thisPartCanvas.height = canvasPartHeight;
  //           const thisPartCtx = thisPartCanvas.getContext("2d");

  //           thisPartCtx.putImageData(
  //             thisHtmlCtx.getImageData(
  //               x0, y0,
  //               thisPartCanvas.width, thisPartCanvas.height
  //             ),
  //             0, 0
  //           );

  //           const thisPartImage = new Image(thisPartCanvas.width, thisPartCanvas.height);
  //           thisPartImage.src = thisPartCanvas.toDataURL();

  //           thisPartImage.addEventListener("load", () => {
  //             try {
  //               console.log(forY, forX, result)
  //               result[forY][forX] = imgAverageColorPicker.getColor(thisPartImage);
  //             } catch (err) { }
  //             if (forX == x - 1) {
  //               ws.send(JSON.stringify({ yLine: forY, colorArray: result[forY] }));
  //             };
  //             if (forY == y - 1 && forX == x - 1) {
  //               resolve(result);
  //             }
  //           })
  //         }
  //       }
  //     })
  //   })
  // }
</script>

</html>